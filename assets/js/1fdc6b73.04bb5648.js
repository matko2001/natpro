"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4983],{3905:function(e,a,i){i.d(a,{Zo:function(){return l},kt:function(){return c}});var r=i(7294);function o(e,a,i){return a in e?Object.defineProperty(e,a,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[a]=i,e}function n(e,a){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),i.push.apply(i,r)}return i}function t(e){for(var a=1;a<arguments.length;a++){var i=null!=arguments[a]?arguments[a]:{};a%2?n(Object(i),!0).forEach((function(a){o(e,a,i[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):n(Object(i)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(i,a))}))}return e}function s(e,a){if(null==e)return{};var i,r,o=function(e,a){if(null==e)return{};var i,r,o={},n=Object.keys(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||(o[i]=e[i]);return o}(e,a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)i=n[r],a.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(o[i]=e[i])}return o}var v=r.createContext({}),p=function(e){var a=r.useContext(v),i=a;return e&&(i="function"==typeof e?e(a):t(t({},a),e)),i},l=function(e){var a=p(e.components);return r.createElement(v.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return r.createElement(r.Fragment,{},a)}},m=r.forwardRef((function(e,a){var i=e.components,o=e.mdxType,n=e.originalType,v=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),m=p(i),c=o,j=m["".concat(v,".").concat(c)]||m[c]||u[c]||n;return i?r.createElement(j,t(t({ref:a},l),{},{components:i})):r.createElement(j,t({ref:a},l))}));function c(e,a){var i=arguments,o=a&&a.mdxType;if("string"==typeof e||o){var n=i.length,t=new Array(n);t[0]=m;var s={};for(var v in a)hasOwnProperty.call(a,v)&&(s[v]=a[v]);s.originalType=e,s.mdxType="string"==typeof e?e:o,t[1]=s;for(var p=2;p<n;p++)t[p]=i[p];return r.createElement.apply(null,t)}return r.createElement.apply(null,i)}m.displayName="MDXCreateElement"},903:function(e,a,i){var r=i(7294);a.Z=function(e){var a=e.authorName,i=e.githubUsername;return r.createElement("div",{className:"author"},"Autor: ",r.createElement("a",{target:"_blank",href:"https://github.com/"+i},a))}},5884:function(e,a,i){var r=i(7294),o=r.useState;a.Z=function(e){var a=e.text,i=o(!1),n=i[0],t=i[1];return r.createElement("span",{onClick:function(){return t(!n)},className:"react-spoiler-"+(n?"shown":"hidden")},a)}},71:function(e,a,i){i.r(a),i.d(a,{frontMatter:function(){return v},contentTitle:function(){return p},metadata:function(){return l},toc:function(){return u},default:function(){return c}});var r=i(7462),o=i(3366),n=(i(7294),i(3905)),t=i(903),s=(i(5884),["components"]),v={title:"Pretra\u017eivanje grafova"},p=void 0,l={unversionedId:"algoritmi-nad-grafovima-1/pretrazivanje-grafova",id:"algoritmi-nad-grafovima-1/pretrazivanje-grafova",title:"Pretra\u017eivanje grafova",description:"Ve\u0107ina algoritama nad grafovima koje \u0107ete koristiti za natjecateljsko programiranje temelje se na nekakvom obilasku svih \u010dvorova grafa kako bi se iz tog obilaska mogli izvu\u0107i nekakvi zaklju\u010dci. Upravo iz tog razloga bitno je razumijeti pretra\u017eivanje u dubinu - depth first search, i pretra\u017eivanje u \u0161irinu - breadth first search. Razumijevanjem tih metoda pretra\u017eivanja i njihovih karakteristika mo\u0107i \u0107ete ih koristiti za jako \u0161iroku paletu problema i po potrebi ih adaptirati za specifi\u010dne probleme.",source:"@site/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova.md",sourceDirName:"algoritmi-nad-grafovima-1",slug:"/algoritmi-nad-grafovima-1/pretrazivanje-grafova",permalink:"/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova",editUrl:"https://github.com/x-fer/natpro/edit/main/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova.md",tags:[],version:"current",frontMatter:{title:"Pretra\u017eivanje grafova"},sidebar:"materijaliSidebar",previous:{title:"Zapisi grafova",permalink:"/docs/algoritmi-nad-grafovima-1/zapisi-grafova"},next:{title:"Najkra\u0107i putovi",permalink:"/docs/algoritmi-nad-grafovima-1/najkraci-putovi"}},u=[{value:"Depth First Search",id:"depth-first-search",children:[{value:"Bitna svojstva i varijacije DFS-a",id:"bitna-svojstva-i-varijacije-dfs-a",children:[],level:4}],level:3},{value:"Breadth First Search",id:"breadth-first-search",children:[{value:"Bitna svojstva i varijacije BFS-a",id:"bitna-svojstva-i-varijacije-bfs-a",children:[],level:4}],level:3}],m={toc:u};function c(e){var a=e.components,v=(0,o.Z)(e,s);return(0,n.kt)("wrapper",(0,r.Z)({},m,v,{components:a,mdxType:"MDXLayout"}),(0,n.kt)(t.Z,{authorName:"Ivan Vlahov",githubUsername:"vlahovivan",mdxType:"Author"}),(0,n.kt)("p",null,"Ve\u0107ina algoritama nad grafovima koje \u0107ete koristiti za natjecateljsko programiranje temelje se na nekakvom obilasku svih \u010dvorova grafa kako bi se iz tog obilaska mogli izvu\u0107i nekakvi zaklju\u010dci. Upravo iz tog razloga bitno je razumijeti pretra\u017eivanje u dubinu - ",(0,n.kt)("em",{parentName:"p"},"depth first search"),", i pretra\u017eivanje u \u0161irinu - ",(0,n.kt)("em",{parentName:"p"},"breadth first search"),". Razumijevanjem tih metoda pretra\u017eivanja i njihovih karakteristika mo\u0107i \u0107ete ih koristiti za jako \u0161iroku paletu problema i po potrebi ih adaptirati za specifi\u010dne probleme."),(0,n.kt)("h3",{id:"depth-first-search"},"Depth First Search"),(0,n.kt)("p",null,"Pretra\u017eivanje u dubinu, ",(0,n.kt)("em",{parentName:"p"},"depth first search"),", ili ukratko DFS, metoda je obilaska \u010dvorova u kojoj prelazimo s jednog \u010dvora na drugi dok god nalazimo nove, neposje\u0107ene \u010dvorove. U slu\u010daju da iz trenutnog \u010dvora ne mo\u017eemo obi\u0107i neki novi \u010dvor, vra\u0107amo se na \u010dvor iz kojeg smo do\u0161li, poku\u0161avamo i\u0107i na neposje\u0107ene \u010dvorove itd. Pretra\u017eivanje zavr\u0161ava kad se posjete svi \u010dvorovi do kojih postoji put iz prvog \u010dvora nad kojim je DFS pozvan."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Primjer grafa nad kojim radimo DFS",src:i(4109).Z,width:"355",height:"355"})),(0,n.kt)("p",null,"Uzmimo na primjer graf sa slike. Recimo da za sljede\u0107i \u010dvor u obilasku biramo prvo onaj neposje\u0107eni \u010dvor s najmanjim indeksom, te da je po\u010detni \u010dvor onaj s indeksom 1. Ozna\u010dimo njega kao posje\u0107enog, te iz njega prelazimo na neposje\u0107eni susjedni \u010dvor s najmanjim indeksom, u ovom slu\u010daju \u010dvor 4. Ponavljamo postupak za \u010dvor 4: ozna\u010davamo ga kao posje\u0107enog, njegovi neposje\u0107eni susjedi su 2 i 5 - prelazimo na \u010dvor 2. Ozna\u010dimo \u010dvor 2 kao posje\u0107enog, prelazimo na \u010dvor 3. Ozna\u010dimo \u010dvor 3 kao posje\u0107enog. Iz \u010dvora 3 nemamo vi\u0161e gdje i\u0107i, pa se vra\u0107amo u \u010dvor iz kojeg smo do\u0161li, a to je \u010dvor 2. Opet tra\u017eimo neposje\u0107enog susjeda \u010dvora 2 s najmanjim indeksom - sad je to \u010dvor 6. Prelazimo na njega, ozna\u010dimo ga kao posje\u0107enog i vra\u0107amo se opet na 2 jer nemamo kamo drugdje iz 6. Sad ni 2 vi\u0161e nema neposje\u0107enih susjeda, pa se vra\u0107amo u 4. Iz 4 idemo u 5, iz 5 se vra\u0107amo u 4, te iz 4 natrag u 1, gdje pretra\u017eivanje zavr\u0161ava."),(0,n.kt)("p",null,"Kad bismo prilikom prvog ulaska u svaki vrh ispisali njegov indeks, dobili bismo sljede\u0107i ispis:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"1 4 2 3 6 5\n")),(0,n.kt)("p",null,"DFS se mo\u017ee implementirati na vi\u0161e na\u010dina. Naj\u010de\u0161\u0107i i jednostavan na\u010din implementacije je rekurzivnim pozivima - zadani \u010dvor ozna\u010dimo kao posje\u0107enog, a zatim redom pozivamo DFS na svim njegovim neposje\u0107enim susjedima."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'// mozete graf deklarirati globalno\n// ili, ako ne zelite, proslijediti \n// referencu na graf funkciji dfs\n// MAXN je neka konstanta, npr. najveci\n// moguci broj vrhova iz teksta zadatka\nvector<vector<int>> graph(MAXN);\n\n// isto vrijedi i za polje posjecenih cvorova\n// visited[i] je true ako je cvor i posjecen,\n// inace false\n// na pocetku je false za sve cvorove\nvector<bool> visited(MAXN, false);\n\nvoid dfs(int node) {\n    visited[node] = true;\n\n    // radi nesto s cvorom, npr. ispis vrha\n    cout << "Usao u cvor " << node << "\\n";\n\n    for(auto &it : graph[node]) {\n        if(!visited[it]) dfs(it);\n    }\n}\n')),(0,n.kt)("p",null,"Pozovemo li sad ovu funkciju na grafu sa slike:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"graph[1] = {4};\ngraph[2] = {3, 4, 6};\ngraph[3] = {2};\ngraph[4] = {1, 2, 5};\ngraph[5] = {4};\ngraph[6] = {2};\n\ndfs(1);\n")),(0,n.kt)("p",null,"Dobit \u0107emo o\u010dekivani ispis:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"Usao u cvor 1\nUsao u cvor 4\nUsao u cvor 2\nUsao u cvor 3\nUsao u cvor 6\nUsao u cvor 5\n")),(0,n.kt)("h4",{id:"bitna-svojstva-i-varijacije-dfs-a"},"Bitna svojstva i varijacije DFS-a"),(0,n.kt)("p",null,"U izradi"),(0,n.kt)("h3",{id:"breadth-first-search"},"Breadth First Search"),(0,n.kt)("p",null,"U izradi"),(0,n.kt)("h4",{id:"bitna-svojstva-i-varijacije-bfs-a"},"Bitna svojstva i varijacije BFS-a"),(0,n.kt)("p",null,"U izradi"))}c.isMDXComponent=!0},4109:function(e,a,i){a.Z=i.p+"assets/images/pretrazivanje1-4fd36327035f37386af68322692b7f88.png"}}]);