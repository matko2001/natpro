"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[4983],{3905:function(e,a,o){o.d(a,{Zo:function(){return m},kt:function(){return l}});var i=o(7294);function n(e,a,o){return a in e?Object.defineProperty(e,a,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[a]=o,e}function r(e,a){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);a&&(i=i.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),o.push.apply(o,i)}return o}function t(e){for(var a=1;a<arguments.length;a++){var o=null!=arguments[a]?arguments[a]:{};a%2?r(Object(o),!0).forEach((function(a){n(e,a,o[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):r(Object(o)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(o,a))}))}return e}function s(e,a){if(null==e)return{};var o,i,n=function(e,a){if(null==e)return{};var o,i,n={},r=Object.keys(e);for(i=0;i<r.length;i++)o=r[i],a.indexOf(o)>=0||(n[o]=e[o]);return n}(e,a);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)o=r[i],a.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var v=i.createContext({}),p=function(e){var a=i.useContext(v),o=a;return e&&(o="function"==typeof e?e(a):t(t({},a),e)),o},m=function(e){var a=p(e.components);return i.createElement(v.Provider,{value:a},e.children)},d={inlineCode:"code",wrapper:function(e){var a=e.children;return i.createElement(i.Fragment,{},a)}},u=i.forwardRef((function(e,a){var o=e.components,n=e.mdxType,r=e.originalType,v=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),u=p(o),l=n,j=u["".concat(v,".").concat(l)]||u[l]||d[l]||r;return o?i.createElement(j,t(t({ref:a},m),{},{components:o})):i.createElement(j,t({ref:a},m))}));function l(e,a){var o=arguments,n=a&&a.mdxType;if("string"==typeof e||n){var r=o.length,t=new Array(r);t[0]=u;var s={};for(var v in a)hasOwnProperty.call(a,v)&&(s[v]=a[v]);s.originalType=e,s.mdxType="string"==typeof e?e:n,t[1]=s;for(var p=2;p<r;p++)t[p]=o[p];return i.createElement.apply(null,t)}return i.createElement.apply(null,o)}u.displayName="MDXCreateElement"},903:function(e,a,o){var i=o(7294);a.Z=function(e){var a=e.authorName,o=e.githubUsername;return i.createElement("div",{className:"author"},"Autor: ",i.createElement("a",{target:"_blank",href:"https://github.com/"+o},a))}},5884:function(e,a,o){var i=o(7294),n=i.useState;a.Z=function(e){var a=e.text,o=n(!1),r=o[0],t=o[1];return i.createElement("span",{onClick:function(){return t(!r)},className:"react-spoiler-"+(r?"shown":"hidden")},a)}},71:function(e,a,o){o.r(a),o.d(a,{frontMatter:function(){return v},contentTitle:function(){return p},metadata:function(){return m},toc:function(){return d},default:function(){return l}});var i=o(7462),n=o(3366),r=(o(7294),o(3905)),t=o(903),s=(o(5884),["components"]),v={title:"Pretra\u017eivanje grafova"},p=void 0,m={unversionedId:"algoritmi-nad-grafovima-1/pretrazivanje-grafova",id:"algoritmi-nad-grafovima-1/pretrazivanje-grafova",title:"Pretra\u017eivanje grafova",description:"Ve\u0107ina algoritama nad grafovima koje \u0107ete koristiti za natjecateljsko programiranje temelje se na nekakvom obilasku svih \u010dvorova grafa kako bi se iz tog obilaska mogli izvu\u0107i nekakvi zaklju\u010dci. Upravo iz tog razloga bitno je razumijeti pretra\u017eivanje u dubinu - depth first search, i pretra\u017eivanje u \u0161irinu - breadth first search. Razumijevanjem tih metoda pretra\u017eivanja i njihovih karakteristika mo\u0107i \u0107ete ih koristiti za jako \u0161iroku paletu problema i po potrebi ih adaptirati za specifi\u010dne probleme.",source:"@site/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova.md",sourceDirName:"algoritmi-nad-grafovima-1",slug:"/algoritmi-nad-grafovima-1/pretrazivanje-grafova",permalink:"/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova",editUrl:"https://github.com/x-fer/natpro/edit/main/docs/algoritmi-nad-grafovima-1/pretrazivanje-grafova.md",tags:[],version:"current",frontMatter:{title:"Pretra\u017eivanje grafova"},sidebar:"materijaliSidebar",previous:{title:"Zapisi grafova",permalink:"/docs/algoritmi-nad-grafovima-1/zapisi-grafova"},next:{title:"Najkra\u0107i putovi",permalink:"/docs/algoritmi-nad-grafovima-1/najkraci-putovi"}},d=[{value:"Depth First Search",id:"depth-first-search",children:[{value:"Bitna svojstva i varijacije DFS-a",id:"bitna-svojstva-i-varijacije-dfs-a",children:[],level:4}],level:3},{value:"Breadth First Search",id:"breadth-first-search",children:[{value:"Bitna svojstva i varijacije BFS-a",id:"bitna-svojstva-i-varijacije-bfs-a",children:[],level:4}],level:3}],u={toc:d};function l(e){var a=e.components,v=(0,n.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},u,v,{components:a,mdxType:"MDXLayout"}),(0,r.kt)(t.Z,{authorName:"Ivan Vlahov",githubUsername:"vlahovivan",mdxType:"Author"}),(0,r.kt)("p",null,"Ve\u0107ina algoritama nad grafovima koje \u0107ete koristiti za natjecateljsko programiranje temelje se na nekakvom obilasku svih \u010dvorova grafa kako bi se iz tog obilaska mogli izvu\u0107i nekakvi zaklju\u010dci. Upravo iz tog razloga bitno je razumijeti pretra\u017eivanje u dubinu - ",(0,r.kt)("em",{parentName:"p"},"depth first search"),", i pretra\u017eivanje u \u0161irinu - ",(0,r.kt)("em",{parentName:"p"},"breadth first search"),". Razumijevanjem tih metoda pretra\u017eivanja i njihovih karakteristika mo\u0107i \u0107ete ih koristiti za jako \u0161iroku paletu problema i po potrebi ih adaptirati za specifi\u010dne probleme."),(0,r.kt)("h3",{id:"depth-first-search"},"Depth First Search"),(0,r.kt)("p",null,"Pretra\u017eivanje u dubinu, ",(0,r.kt)("em",{parentName:"p"},"depth first search"),", ili ukratko DFS, metoda je obilaska \u010dvorova u kojoj prelazimo s jednog \u010dvora na drugi dok god nalazimo nove, neposje\u0107ene \u010dvorove. U slu\u010daju da iz trenutnog \u010dvora ne mo\u017eemo obi\u0107i neki novi \u010dvor, vra\u0107amo se na \u010dvor iz kojeg smo do\u0161li, poku\u0161avamo i\u0107i na neposje\u0107ene \u010dvorove itd. Pretra\u017eivanje zavr\u0161ava kad se posjete svi \u010dvorovi do kojih postoji put iz prvog \u010dvora nad kojim je DFS pozvan."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Primjer grafa nad kojim radimo DFS",src:o(4109).Z,width:"355",height:"355"})),(0,r.kt)("p",null,"Uzmimo na primjer graf sa slike. Recimo da za sljede\u0107i \u010dvor u obilasku biramo prvo onaj neposje\u0107eni \u010dvor s najmanjim indeksom, te da je po\u010detni \u010dvor onaj s indeksom 1. Ozna\u010dimo njega kao posje\u0107enog, te iz njega prelazimo na neposje\u0107eni susjedni \u010dvor s najmanjim indeksom, u ovom slu\u010daju \u010dvor 4. Ponavljamo postupak za \u010dvor 4: ozna\u010davamo ga kao posje\u0107enog, njegovi neposje\u0107eni susjedi su 2 i 5 - prelazimo na \u010dvor 2. Ozna\u010dimo \u010dvor 2 kao posje\u0107enog, prelazimo na \u010dvor 3. Ozna\u010dimo \u010dvor 3 kao posje\u0107enog. Iz \u010dvora 3 nemamo vi\u0161e gdje i\u0107i, pa se vra\u0107amo u \u010dvor iz kojeg smo do\u0161li, a to je \u010dvor 2. Opet tra\u017eimo neposje\u0107enog susjeda \u010dvora 2 s najmanjim indeksom - sad je to \u010dvor 6. Prelazimo na njega, ozna\u010dimo ga kao posje\u0107enog i vra\u0107amo se opet na 2 jer nemamo kamo drugdje iz 6. Sad ni 2 vi\u0161e nema neposje\u0107enih susjeda, pa se vra\u0107amo u 4. Iz 4 idemo u 5, iz 5 se vra\u0107amo u 4, te iz 4 natrag u 1, gdje pretra\u017eivanje zavr\u0161ava."),(0,r.kt)("p",null,"Kad bismo prilikom prvog ulaska u svaki vrh ispisali njegov indeks, dobili bismo sljede\u0107i ispis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 4 2 3 6 5\n")),(0,r.kt)("p",null,"DFS se mo\u017ee implementirati na vi\u0161e na\u010dina. Naj\u010de\u0161\u0107i i jednostavan na\u010din implementacije je rekurzivnim pozivima - zadani \u010dvor ozna\u010dimo kao posje\u0107enog, a zatim redom pozivamo DFS na svim njegovim neposje\u0107enim susjedima."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'// mozete graf deklarirati globalno\n// ili, ako ne zelite, proslijediti \n// referencu na graf funkciji dfs\n// MAXN je neka konstanta, npr. najveci\n// moguci broj vrhova iz teksta zadatka\nvector<vector<int>> graph(MAXN);\n\n// isto vrijedi i za polje posjecenih cvorova\n// visited[i] je true ako je cvor i posjecen,\n// inace false\n// na pocetku je false za sve cvorove\nvector<bool> visited(MAXN, false);\n\nvoid dfs(int node) {\n    visited[node] = true;\n\n    // radi nesto s cvorom, npr. ispis vrha\n    cout << "Usao u cvor " << node << "\\n";\n\n    for(auto &it : graph[node]) {\n        if(!visited[it]) dfs(it);\n    }\n}\n')),(0,r.kt)("p",null,"Pozovemo li sad ovu funkciju na grafu sa slike:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"graph[1] = {4};\ngraph[2] = {3, 4, 6};\ngraph[3] = {2};\ngraph[4] = {1, 2, 5};\ngraph[5] = {4};\ngraph[6] = {2};\n\ndfs(1);\n")),(0,r.kt)("p",null,"Dobit \u0107emo o\u010dekivani ispis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Usao u cvor 1\nUsao u cvor 4\nUsao u cvor 2\nUsao u cvor 3\nUsao u cvor 6\nUsao u cvor 5\n")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"primijetite")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Ne postoji razlika u implementaciji ako se radi o usmjerenom grafu."))),(0,r.kt)("h4",{id:"bitna-svojstva-i-varijacije-dfs-a"},"Bitna svojstva i varijacije DFS-a"),(0,r.kt)("p",null,"U izradi"),(0,r.kt)("h3",{id:"breadth-first-search"},"Breadth First Search"),(0,r.kt)("p",null,'Drugi na\u010din pretra\u017eivanja grafova jest pretra\u017eivanje u \u0161irinu. Ideja ove metode je da \u010dvorove obra\u0111ujemo po "slojevima" - obradimo po\u010detni \u010dvor, taj \u010dvor je dio sloja 0, zatim njegove neposje\u0107ene susjede - sloj 1, pa neposje\u0107ene susjede \u010dvorova iz sloja 1 - oni su dio sloja 2, i tako dalje dok ne obradimo sve \u010dvorove do kojih postoji put iz po\u010detnog \u010dvora.'),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Primjer grafa nad kojim radimo BFS",src:o(4773).Z,width:"355",height:"355"})),(0,r.kt)("p",null,"Zapo\u010dnemo li pretra\u017eivanje u \u0161irinu na grafu sa slike u \u010dvoru 1, i ako opet pretpostavimo da su susjedi sortirani uzlazno po indeksu, algoritam \u0107e se pona\u0161ati na sljede\u0107i na\u010din. Obradimo \u010dvor jedan, ozna\u010dimo ga kao posje\u0107enog, te redom posje\u0107ujemo njegove neposje\u0107ene susjede - to su redom \u010dvorovi 3, 5 i 6. Nakon toga posje\u0107ujemo sve neposje\u0107ene susjede \u010dvora 3 - to je \u010dvor 4, pa neposje\u0107ene susjede \u010dvora 5 - to su \u010dvorovi 2 i 7, pa neposje\u0107ene susjede \u010dvora 6 - takvih \u010dvorova vi\u0161e nema. Nakon toga poku\u0161avamo posjetiti neposje\u0107ene susjede \u010dvorova 4, 2 i 7, me\u0111utim oni nemaju niti jednog neposje\u0107enog susjeda, pa algoritam zavr\u0161ava."),(0,r.kt)("p",null,(0,r.kt)("img",{alt:"Graf sa slojevima obojanim u razli\u010dite boje",src:o(3730).Z,width:"355",height:"355"})),(0,r.kt)("p",null,"Kad bismo prilikom posjeta \u010dvora ispisali njegov vrh, dobili bismo ovakav ispis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"1 3 5 6 4 2 7\n")),(0,r.kt)("p",null,"Implementacija BFS-a temelji se na kori\u0161tenju reda. Po\u010detni \u010dvor dodamo u red te ponavljamo sljede\u0107i postupak sve dok se red ne isprazni: skinemo \u010dvor s po\u010detka reda, ako ve\u0107 nije posje\u0107en obradimo ga, ozna\u010dimo ga kao posje\u0107enog, te na kraj reda dodamo sve njegove neposje\u0107ene susjede."),(0,r.kt)("p",null,"U C++-u ta implementacija izgleda ovako, npr. za graf sa slike i po\u010detni \u010dvor 1:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'graph[1] = {3, 5, 6};\ngraph[2] = {5, 6, 7};\ngraph[3] = {1, 4, 5};\ngraph[4] = {3, 5, 7};\ngraph[5] = {1, 2, 3, 4, 6, 7};\ngraph[6] = {1, 2, 5};\ngraph[7] = {2, 4, 5};\n\nqueue<int> q;\n\n// pocetni cvor rucno dodajemo u red\nq.push(1);\n\nwhile(!q.empty()) {\n    int node = q.front();\n    q.pop();\n\n    if(visited[node]) continue;\n    visited[node] = true;\n\n    // radi nesto s cvorom, npr. ispis vrha\n    cout << "Usao u cvor " << node << "\\n";\n\n    for(auto &it : graph[node]) {\n        if(!visited[it]) {\n        q.push(it);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"Ovaj isje\u010dak koda daje o\u010dekivani ispis:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Usao u cvor 1\nUsao u cvor 3\nUsao u cvor 5\nUsao u cvor 6\nUsao u cvor 4\nUsao u cvor 2\nUsao u cvor 7\n")),(0,r.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"primijetite")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Za razliku od DFS-a, u BFS-u moramo raditi provjeru je li neki vrh posje\u0107en i za taj sami vrh i za njegove susjede. Razlog je \u010dinjenica da dva razli\u010dita \u010dvora koja su dio istog sloja mogu dodati istog susjeda u red dva puta, pa se moramo pobrinuti da se \u010dvor ne obradi opet drugi put kad se na\u0111e na po\u010detku reda."))),(0,r.kt)("h4",{id:"bitna-svojstva-i-varijacije-bfs-a"},"Bitna svojstva i varijacije BFS-a"),(0,r.kt)("p",null,"U izradi"))}l.isMDXComponent=!0},4109:function(e,a,o){a.Z=o.p+"assets/images/pretrazivanje1-4fd36327035f37386af68322692b7f88.png"},4773:function(e,a,o){a.Z=o.p+"assets/images/pretrazivanje2-131f629a9187045ef62bfccfda253d73.png"},3730:function(e,a,o){a.Z=o.p+"assets/images/pretrazivanje3-5dea4945c6cc5ff1e0d8d071d00e2b4d.png"}}]);