"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[9977],{3905:(a,e,t)=>{t.d(e,{Zo:()=>l,kt:()=>u});var n=t(7294);function s(a,e,t){return e in a?Object.defineProperty(a,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):a[e]=t,a}function m(a,e){var t=Object.keys(a);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(a);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(a,e).enumerable}))),t.push.apply(t,n)}return t}function r(a){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?m(Object(t),!0).forEach((function(e){s(a,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(t)):m(Object(t)).forEach((function(e){Object.defineProperty(a,e,Object.getOwnPropertyDescriptor(t,e))}))}return a}function o(a,e){if(null==a)return{};var t,n,s=function(a,e){if(null==a)return{};var t,n,s={},m=Object.keys(a);for(n=0;n<m.length;n++)t=m[n],e.indexOf(t)>=0||(s[t]=a[t]);return s}(a,e);if(Object.getOwnPropertySymbols){var m=Object.getOwnPropertySymbols(a);for(n=0;n<m.length;n++)t=m[n],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(a,t)&&(s[t]=a[t])}return s}var i=n.createContext({}),p=function(a){var e=n.useContext(i),t=e;return a&&(t="function"==typeof a?a(e):r(r({},e),a)),t},l=function(a){var e=p(a.components);return n.createElement(i.Provider,{value:e},a.children)},k="mdxType",c={inlineCode:"code",wrapper:function(a){var e=a.children;return n.createElement(n.Fragment,{},e)}},N=n.forwardRef((function(a,e){var t=a.components,s=a.mdxType,m=a.originalType,i=a.parentName,l=o(a,["components","mdxType","originalType","parentName"]),k=p(t),N=s,u=k["".concat(i,".").concat(N)]||k[N]||c[N]||m;return t?n.createElement(u,r(r({ref:e},l),{},{components:t})):n.createElement(u,r({ref:e},l))}));function u(a,e){var t=arguments,s=e&&e.mdxType;if("string"==typeof a||s){var m=t.length,r=new Array(m);r[0]=N;var o={};for(var i in e)hasOwnProperty.call(e,i)&&(o[i]=e[i]);o.originalType=a,o[k]="string"==typeof a?a:s,r[1]=o;for(var p=2;p<m;p++)r[p]=t[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,t)}N.displayName="MDXCreateElement"},903:(a,e,t)=>{t.d(e,{Z:()=>s});var n=t(7294);const s=a=>{let{authorName:e,githubUsername:t}=a;return n.createElement("div",{className:"author"},"Autor: ",n.createElement("a",{target:"_blank",href:"https://github.com/"+t},e))}},5884:(a,e,t)=>{t.d(e,{Z:()=>m});var n=t(7294);const{useState:s}=n,m=a=>{let{text:e}=a;const[t,m]=s(!1);return n.createElement("span",{onClick:()=>m(!t),className:"react-spoiler-"+(t?"shown":"hidden")},e)}},2768:(a,e,t)=>{t.r(e),t.d(e,{assets:()=>p,contentTitle:()=>o,default:()=>N,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var n=t(7462),s=(t(7294),t(3905)),m=t(903);t(5884);const r={title:"Topolo\u0161ko sortiranje"},o=void 0,i={unversionedId:"algoritmi-nad-grafovima-2/topolosko-sortiranje",id:"algoritmi-nad-grafovima-2/topolosko-sortiranje",title:"Topolo\u0161ko sortiranje",description:"Uvod",source:"@site/docs/algoritmi-nad-grafovima-2/topolosko-sortiranje.md",sourceDirName:"algoritmi-nad-grafovima-2",slug:"/algoritmi-nad-grafovima-2/topolosko-sortiranje",permalink:"/docs/algoritmi-nad-grafovima-2/topolosko-sortiranje",draft:!1,editUrl:"https://github.com/x-fer/natpro/edit/main/docs/algoritmi-nad-grafovima-2/topolosko-sortiranje.md",tags:[],version:"current",frontMatter:{title:"Topolo\u0161ko sortiranje"},sidebar:"materijaliSidebar",previous:{title:"MST",permalink:"/docs/algoritmi-nad-grafovima-1/mst"},next:{title:"Kosarajuev algoritam",permalink:"/docs/algoritmi-nad-grafovima-2/kosarajuev-algoritam"}},p={},l=[{value:"Uvod",id:"uvod",level:3},{value:"DFS algoritam",id:"dfs-algoritam",level:3},{value:"Kahnov algoritam",id:"kahnov-algoritam",level:3},{value:"Najkra\u0107i putevi",id:"najkra\u0107i-putevi",level:3},{value:"Hamiltonov put",id:"hamiltonov-put",level:3}],k={toc:l},c="wrapper";function N(a){let{components:e,...r}=a;return(0,s.kt)(c,(0,n.Z)({},k,r,{components:e,mdxType:"MDXLayout"}),(0,s.kt)(m.Z,{authorName:"Martin Josip Kocijan",githubUsername:"kocijan",mdxType:"Author"}),(0,s.kt)("h3",{id:"uvod"},"Uvod"),(0,s.kt)("p",null,"Za neki graf ka\u017eemo da je ",(0,s.kt)("strong",{parentName:"p"},"usmjereni")," (engl. ",(0,s.kt)("em",{parentName:"p"},"directed"),") ako je svakom bridu odre\u0111eno iz kojeg vrha ide u koji vrh. ",(0,s.kt)("strong",{parentName:"p"},"Put")," (engl. ",(0,s.kt)("em",{parentName:"p"},"path"),") je u usmjerenom grafu niz bridova takvih da svaki zavr\u0161ava u onom vrhu u kojem sljede\u0107i brid po\u010dinje. ",(0,s.kt)("strong",{parentName:"p"},"Ciklus")," (engl. ",(0,s.kt)("em",{parentName:"p"},"cycle"),") jest put u kojem zadnji brid zavr\u0161ava u vrhu u kojem po\u010dinje prvi brid."),(0,s.kt)("p",null,"Usmjereni graf mo\u017eemo topolo\u0161ki poredati ako i samo ako postoji permutacija liste njegovih vrhova, tako da za svaki brid vrijedi da se njegov po\u010detni vrh pojavljuje ranije u listi od njegovog zavr\u0161nog vrha. Ako postoji topolo\u0161ki poredak nekog usmjerenog grafa, on ne smije sadr\u017eavati nijedan ciklus. U protivnom bismo dobili kontradikciju za prvi i zadnji vrh nekog ciklusa u poretku. S druge strane svakom usmjerenom grafu bez ciklusa mo\u017eemo pridru\u017eiti barem jedan topolo\u0161ki poredak."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Primjer usmjerenog grafa bez ciklusa",src:t(2796).Z,width:"2550",height:"2048"})),(0,s.kt)("p",null,"Na slici je neki usmjereni graf bez ciklusa, i za njega postoji puno topolo\u0161kih poredaka, npr."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"5")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"5")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"5"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"7")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"7")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"7"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"3")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"3")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"3"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"11")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"11")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"8")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"8")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"8"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"2")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"2")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"2"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"9")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"9")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"9"))))),", ",(0,s.kt)("span",{parentName:"li",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mn",{parentName:"mrow"},"10")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"10")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.64444em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord"},"1"),(0,s.kt)("span",{parentName:"span",className:"mord"},"0"))))))),(0,s.kt)("p",null,"Da bismo dobili neki topolo\u0161ki poredak, moramo provesti obilazak grafa tako da neki \u010dvor obra\u0111ujemo tek dok smo obradili sve \u010dvorove koji imaju brid prema njemu. Postoje algoritmi DFS i Kahnov algoritam koji to rje\u0161avaju. Oba algoritma usput saznaju postoji li uop\u0107e topolo\u0161ki poredak. Ako on ne postoji, to je zbog ciklusa kojeg DFS mo\u017ee otkriti."),(0,s.kt)("h3",{id:"dfs-algoritam"},"DFS algoritam"),(0,s.kt)("p",null,"Topolo\u0161ki poredak mo\u017eemo dobiti tako da okrenemo popis obra\u0111enih \u010dvorova u post-order obilasku svih \u010dvorova DFS-om."),(0,s.kt)("p",null,"U glavnom programu petljom prolazimo kroz sve \u010dvorove i za svakog rekurzivno pozivamo DFS pretragu. Rekurzivna funkcija zavr\u0161ava kad ne mo\u017ee zvati nijedan susjedni \u010dvor koji jo\u0161 nije obra\u0111en. Unutar funkcije zovemo svaki susjedni \u010dvor koji jo\u0161 nismo zvali, te na kraju na po\u010detak tra\u017eenog topolo\u0161kog poretka zapisujemo trenutni \u010dvor (npr. sa stogom). Ovo nam garantira da, kad zapisujemo neki \u010dvor u listu, svaki \u010dvor koji ovisi o trenutnom \u010dvoru ve\u0107 bude zapisan u listi s desna. Postoje dvije situacije koje su nas dovele do toga. Ili smo do tog ovisnog \u010dvora do\u0161li rekurzivno od trenutnog, ili smo rekurzivno obra\u0111ivali taj \u010dvor prije nego li smo uop\u0107e u\u0161li u trenutni."),(0,s.kt)("p",null,"Ciklus pronalazimo ako postoji brid iz trenutnog \u010dvora u neki koji je na\u0161 trenutni predak (obrada njegove rekurzije jo\u0161 je na stogu). Zato priliskom ulaska u neki \u010dvor njega ozna\u010dujemo kao pozvanog, a prilikom izlaska ga ozna\u010dujemo kao obra\u0111enog. Ako je \u010dvor ve\u0107 pozvan, imamo ciklus i prekidamo algoritam. Ako pak je \u010dvor ve\u0107 obra\u0111en, tada ga samo preska\u010demo jer je ve\u0107 dodan u rje\u0161enje. Svaki \u010dvor posje\u0107ujemo samo jednom, pa je algoritam slo\u017eenosti ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"N"),(0,s.kt)("mo",{parentName:"mrow"},"+"),(0,s.kt)("mi",{parentName:"mrow"},"M"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N+M)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'void toposort(int cvor) {\n    if (pozvana[cvor]) { //ima ciklus\n        cout << "Impossible" << endl;\n        exit(0);\n    }\n    // ozna\u010dimo da upravo obra\u0111ujemo trenutni \u010dvor\n    pozvana[cvor] = 1;\n    for (int i = 0; i < graf[cvor].size(); ++i)\n        if (!bio[graf[cvor][i]])\n            toposort(graf[cvor][i]);\n    // ozna\u010dimo da ne moramo opet obraditi trenutni \u010dvor\n    bio[cvor] = 1;\n    // ozna\u010dimo da smo prestali s obradom trenutnog \u010dvora\n    pozvana[cvor] = 0;\n    topo.push_back(cvor);\n}\n// ...\n// u funkciji main()\n    for (int i = 0; i < n; ++i) {\n        if(!bio[i])\n            toposort(i);\n    }\n    // ispi\u0161emo topolo\u0161ki poredak\n    for (int i = n - 1; i >= 0; --i)\n        cout << topo[i] << " ";\n    cout << endl;\n')),(0,s.kt)("h3",{id:"kahnov-algoritam"},"Kahnov algoritam"),(0,s.kt)("p",null,"Jo\u0161 jedan na\u010din da topolo\u0161ki sortiramo vrhove nekog grafa jest Kahnov algoritam. On je sli\u010dniji BFS-u nego DFS-u."),(0,s.kt)("p",null,"Algoritam funkcionira tako da odr\u017eavamo popis (bilokoja struktura podataka) vrhova koji nemaju nijedan ulazni brid iz nekog vrha kojeg jo\u0161 nismo dodali u rje\u0161enje. Na po\u010detku se popis sastoji od svih vrhova kojima nemaju nijedan ulazni brid. Uvijek postoji barem jedan takav vrh u svakom nepraznom usmjerenom grafu bez ciklusa. Zatim dodajemo jedan po jedan vrh ",(0,s.kt)("em",{parentName:"p"},"u")," s tog popisa na kraj rje\u0161enja, i radimo sljede\u0107e za svakog njegovog susjeda ",(0,s.kt)("em",{parentName:"p"},"v"),":"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"uklonimo brid od ",(0,s.kt)("em",{parentName:"li"},"u")," prema ",(0,s.kt)("em",{parentName:"li"},"v")),(0,s.kt)("li",{parentName:"ul"},"ako ",(0,s.kt)("em",{parentName:"li"},"v")," nema nijedan drugi ulazni brid, dodajemo ga na popis da ga kasnije mo\u017eemo obraditi")),(0,s.kt)("p",null,"Ako smo uklonili sve bridove iz grafa, odnosno obradili sve \u010dvorove, prona\u0161li smo neko rje\u0161enje. Ina\u010de sigurno postoji barem jedan ciklus pa ne postoji nijedno rje\u0161enje."),(0,s.kt)("p",null,"Ovaj algoritam rje\u0161enje pronalazi ispravnim redoslijedom pa ga ne moramo okrenuti na kraju kao kad smo koristili DFS."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},'for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < graf[cvor].size(); ++j)\n        in_degree[graf[cvor][j]]++;\n}\nfor (int i = 0; i < n; ++i)\n    if (in_degree[i] == 0)\n        q.push(i);\n\nint cnt;\nfor (cnt = 0; !q.empty(); ++cnt) {\n    // dodamo u rje\u0161enje i obradimo neki vrh iz reda\n    int u = q.front();\n    q.pop();\n    topo.push_back(u);\n\n   for (int j = 0; j < graf[u].size(); ++j)\n        // uklanjamo izlazni brid iz trenutnog vrha tako da ulazni stupanj svakog njegovog susjeda smanjimo za 1\n        --in_degree[graf[u][j]];\n        // ako ne postoji nijedan drugi ulazni brid prema susjedu mo\u017eemo ga obraditi\n        if (in_degree[graf[u][j]] == 0)\n            q.push(graf[u][j]);\n        // primjetimo da kad tra\u017eimo neki vrh koji je ulaznog stupnja 0, dovoljno je odr\u017eavati popis takvih vrhova koji potencijalno a\u017euriramo samo onda kada obra\u0111ujemo neki vrh koji ulazi u njih\n}\n\nif (cnt < n) { // ima ciklus\n    cout << "Impossible" << endl;\n    exit(0);\n}\n// ispi\u0161emo topolo\u0161ki poredak\nfor (int i = 0; i < n; ++i)\n    cout << topo[i] << " ";\ncout << endl;\n')),(0,s.kt)("h3",{id:"najkra\u0107i-putevi"},"Najkra\u0107i putevi"),(0,s.kt)("p",null,"Ako nas zanimaju najkra\u0107i putevi od nekog vrha do svakog drugog vrha u usmjerenom grafu bez ciklusa, mo\u017eemo koristiti topolo\u0161ko sortiranje. Ako graf ima ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"N")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"N")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N")))))," vrhova i ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"M")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"M")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"0.68333em",verticalAlign:"0em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M")))))," bridova, posti\u0107i \u0107emo linearnu slo\u017eenost od ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"N"),(0,s.kt)("mo",{parentName:"mrow"},"+"),(0,s.kt)("mi",{parentName:"mrow"},"M"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(N + M)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"N"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}}),(0,s.kt)("span",{parentName:"span",className:"mbin"},"+"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2222222222222222em"}})),(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),", umjesto Dijkstrine slo\u017eenosti od npr. ",(0,s.kt)("span",{parentName:"p",className:"math math-inline"},(0,s.kt)("span",{parentName:"span",className:"katex"},(0,s.kt)("span",{parentName:"span",className:"katex-mathml"},(0,s.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,s.kt)("semantics",{parentName:"math"},(0,s.kt)("mrow",{parentName:"semantics"},(0,s.kt)("mi",{parentName:"mrow"},"O"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},"("),(0,s.kt)("mi",{parentName:"mrow"},"M"),(0,s.kt)("mi",{parentName:"mrow"},"log"),(0,s.kt)("mo",{parentName:"mrow"},"\u2061"),(0,s.kt)("mi",{parentName:"mrow"},"M"),(0,s.kt)("mo",{parentName:"mrow",stretchy:"false"},")")),(0,s.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"O(M \\log M)")))),(0,s.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,s.kt)("span",{parentName:"span",className:"base"},(0,s.kt)("span",{parentName:"span",className:"strut",style:{height:"1em",verticalAlign:"-0.25em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.02778em"}},"O"),(0,s.kt)("span",{parentName:"span",className:"mopen"},"("),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,s.kt)("span",{parentName:"span",className:"mop"},"lo",(0,s.kt)("span",{parentName:"span",style:{marginRight:"0.01389em"}},"g")),(0,s.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.16666666666666666em"}}),(0,s.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.10903em"}},"M"),(0,s.kt)("span",{parentName:"span",className:"mclose"},")"))))),"."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-cpp"},"for (int i = 0; i < n; ++i) {\n    dist[i] = 0x3f3f3f3f; // ili 1e9\n}\ndist[pocetni_vrh] = 0;\nfor (int i = 0; i < n; ++i) {\n    int u = topo[i];\n    for (int j = 0; j < graf[u].size(); ++j) {\n        if (dist[graf[u][j]] > dist[u] + graf_dist[u][j])\n            dist[graf[u][j]] = dist[u] + graf_dist[u][j];\n    }\n}\n")),(0,s.kt)("h3",{id:"hamiltonov-put"},"Hamiltonov put"),(0,s.kt)("p",null,"Op\u0107enito je problem pronala\u017eenja Hamiltonovih puteva u usmjerenim grafovima nemogu\u0107e rije\u0161iti u polinomskoj slo\u017eenosti. U slu\u010daju kada ne postoji nijedan ciklus, mogu\u0107e je taj problem rije\u0161iti u \u010dak linearnoj slo\u017eenosti. Opet koristimo topolo\u0161ko sortiranje, te promatramo je li ono jedinstveno. Naime, dovoljno je provjeriti postoji li brid izme\u0111u svaka dva susjedna vrha u topolo\u0161kom poretku. Ako je tako, topolo\u0161ki je poredak jedinstven te taj niz bridova \u010dini Hamiltonov put u grafu. Ako pak su neka dva vrha susjedna u topolo\u0161kom poretku ali izme\u0111u njih ne postoji brid, tada ih mo\u017eemo zamijeniti. Dobit \u0107emo jo\u0161 jedan valjan topolo\u0161ki poredak, pa zaklju\u010dujemo da on nije jedinstven."))}N.isMDXComponent=!0},2796:(a,e,t)=>{t.d(e,{Z:()=>n});const n=t.p+"assets/images/dag1-4c6ddff9b0ff97e09d2c4ef2c55d0013.png"}}]);